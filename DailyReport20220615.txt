作業内容
・JavaScriptチュートリアル
　開始：コード品質-忍者コード-名前の再利用
　終了：オブジェクト：基本-オプショナルチェイニング(Optionalchaining)'?.'
以下本日の学習内容

#コード品質
##忍者コード
・変数名の再利用をしない

・意味なく変数名の前に_を置かない

・super,mega,niceなど、抽象的な名前は使わない

・関数の内側と外側で同じ変数名を利用しない

・is...,check...,find...というように名付けた関数では、外側のものを変更するような処理を行わない
　また、check...というように明らかにtrue,falseを返すような関数では複雑なオブジェクトを返さない

・関数には名前に沿った一つのアクションのみを記述し、その他のアクションを追加しない

##mochaによる自動テスト
・ビヘイビア駆動開発（BDD）
　spec(specification)とは関数が何をすべきか考え、それを記述すること
　specのdescribe("title", function() {...} では、どのような機能について記述しているのか、itのブロックをグループ化するために利用する
　specのit("title",function(){...})では、特定のユースケースを人間が読めるように記述し、2番目の引数はそれをテストするための関数
　specのassert.equal(value1,value2)では、value1とvalue2の値を比較し、等しくない場合にエラーを返す

・通常の開発フロー
　1,最も基本的な機能のテストとともに、初期のspecが書かれる
　2,最初の実装が作成
　3,動作確認のため、テストフレームワークのMochaを使用してspecを実行する
　　エラーが表示されなくなるまで修正を行う
　4,これで、テスト付きの動作可能な初期の実装ができあがる
　5,まだ実装ではサポートされていないユースケースをさらにspecに追加していく。
　6,3に戻り、テストのエラーがなくなるまで実装を更新する
　7,機能が完成するまで3～6のステップを繰り返す

・テストはitブロックをいくつも書く方法だけでなく、forで生成することもできる

・describeはネストすることができ、テストしたい内容ごとにdescribeでまとめると見やすい

・テストを実行する前後に実行するbefore/after関数を設定することができる
　また、すべてのitの前後で実行するbeforeEach/afterEachもある
　これらは通常、カウンタを0にしたり、テストの間で何かをするなど、初期化の実行のために使われる

・assert.isNaNは引数の値がNaNでないときエラーを表示する

・アサーション一覧
　assert.equal(value1, value2) - value1とvalue2が等しいかどうかを==でチェック
　assert.strictEqual(value1, value2) - 厳密な等価(===)をチェック
　assert.notEqual, assert.notStrictEqual - 等価でない(!=, !==)ことをチェック
　assert.isTrue(value) - value === trueをチェック
　assert.isFalse(value) - value === falseをチェック
  その他のアサーションはhttps://www.chaijs.com/api/assert/で確認する

・specは、テスト、ドキュメント、使用例として使える

・specを書くのは難しいが、最終的には開発を速く、よりバグを少なくすることができる

・一つのitブロックには一つのassert

##Polyfill(ポリフィル)とトランスパイラ
・最新の機能をサポートしていない古いエンジンで最新のコードを動作させるためには、トランスパイラまたは、Polyfill（ポリフィル）を用いる

・トランスパイラとはソースコードを別のソースコードに変換する特別なソフトウェア
　最新のコードを解析し、古い構文を使って書きかえることで、古いエンジンでも動作するようになる
　通常、開発者は自身のコンピュータ上でトランスパイラを実行し、トランスパイルしたコードをサーバにデプロイする
　Babelは最も著名なトランスパイラの一つ
　webpackのような最新のプロジェクトビルドシステムは、コードが変更されるたびに自動的にトランスパイラを実行する手段を提供しており、開発プロセスに組み込むのがとても簡単
　
・新しい言語の組み込み関数といった、新しい機能を更新/追加するスクリプトをpolyfil(ポリフィル)と呼ぶ
　Math.trunc(n)のような古いバージョンでは実装されていない組み込み関数を、古いバージョンでも同じ動作を行えるように記述する

#オブジェクト：基本
##オブジェクト
・7つの基本型はプリミティブと呼ばれ、単一の値のみを持つ

・空のオブジェクトは [let 変数名 = new Object();] または [let 変数名 = {};]で生成できる

・オブジェクトの宣言はオブジェクトリテラルと呼ばれる

・オブジェクトは [object名.追加したいキー名 = 値;] で要素を追加できる

・オブジェクトの要素を削除するには [delete オブジェクト名.削除したいキー名;]　で削除できる

・複数単語からなるキー名を用いたい場合は、引用符で囲む [ "likes birds" : true ]
　ただし、複数語のプロパティの場合は、ドットを使用したアクセスができないため、角括弧表記を用いる
　例：user["like birds"] = true;
      //上記と同じ動作
      let key = "like birds";
　　　user[key] = true;
　逆に、ドット表記では、
　　　let key = "name";
　　　alert(user.key);というようには使えない

・オブジェクトリテラルでは、角括弧を使うことができ、それを算出プロパティと呼ぶ
　例：let fruit = prompt("Which fruit to buy?", "apple");
　　　let bag = {
　　　　　[fruit]: 5,
　　　};
　　　alert( bag.apple ); // 5 fruit="apple"の場合
　また、角括弧内では文字列の連結など複雑な式を使うこともできる

・オブジェクトリテラルでは基本的にはドットが使われ、複雑な何かが必要なときに角括弧に切り替える

・オブジェクトを作成する際に、プロパティと変数名が同じ場合、単に変数名を書くだけでオブジェクトの作成ができる
　例:function makeUser(name, age) {
　　   return {
　　　   name, //name: name
　　　　 age, //age: age
　　　 };
　　 }
      let user = {
        name,　//name: name
        age: 30,
      };

・オブジェクトのプロパティ名には制限がなく、任意の文字列またはシンボルを使用することができる
　他のタイプの場合は、自動的に文字列に変換される

・JavaScriptでは他の言語とは異なり、存在しないプロパティへのアクセスはエラーにならず、undefinedを返す

・プロパティの存在チェックをするための演算子として"in"がある
　例：let user = { name: "John", age: 30 };
      alert( "age" in user ); //true
      alert( "blabla" in user ); // false
      let key = "age";
      alert( key in user ); //true
　また、in演算子はプロパティにundefinedが格納されている場合でも正しく動く

・for..inループではオブジェクトのすべてのキーを見て回ることができる
　例：let user = {
        name: "John",
        age: 30,
        isAdmin: true,
      };
      // name, John, age, 30, isAdmin, trueが順にアラートされる
      for(let key in user) { //ループ内でループする変数を宣言する
         alert(key);  
         alert(user[key]); 
　    }

・オブジェクトのプロパティは整数値の場合はソートされ昇順に、それ以外の場合は作成した順になる

・整数プロパティとは変更なしに変換できる文字列のこと
　例："49"
  誤った例："+49", "1.2"

・+("+1")が数値の1として変換されるのは、文字列の"+"が正の値を示す+として認識されるから

##オブジェクト参照とコピー
・プリミティブの場合は値をコピーすると、2つの独立した変数ができる
　一方、オブジェクトに割り当てられた変数は、オブジェクト自体ではなく、オブジェクトへの参照（ポインタ）を格納する
　そのため、オブジェクトをコピーすると参照はコピーされるが、オブジェクト自体は複製されない

・JavaScriptにはクローンのための組み込みメソッドはない
　そのため、オブジェクトの複製をする場合には、for..inループを用いて、プリミティブなレベルでプロパティを繰り返しコピーする
　例：for(let key in user){
        clone[key] = user[key];
      }
　また、Object.assignメソッドを用いることで複製することもできる
　例：let user = { name: "John" };

　　　let permissions1 = { canView: true };
　　　let permissions2 = { canEdit: true };

　　　Object.assign(user, permissions1, permissions2);

　　　// now user = { name: "John", canView: true, canEdit: true }
　
　また、Object.assignメソッドでは、既に同じプロパティ名のものをもっていた場合には、上書きをする
　さらに、for..inループを用いずに[ let clone = Object.assign({}, user);]とすることで同じ処理を行える

・オブジェクトの中にさらにオブジェクトがある場合には、上記の方法では複製することができない
　複製したい場合には、オブジェクトのプロパティの各値を調べ、それがオブジェクトの場合にはその構造も複製するというループを行う必要がある
　これを、ディープクローン（ディープコピー）と呼ぶ
　
・constオブジェクトのプロパティは変更可能

##ガベージコレクション
・ガベージコレクションとは使われなくなったオブジェクトを削除し、使用メモリ容量を減らすもの
　JavaScriptでは到達可能な値（いずれかのオブジェクトから参照れている状態）は削除せず、到達不可能な値を削除する

・ガベージコレクションをより速く行うための最適化を行っており、世代コレクション、インクリメンタルコレクション、アイドルタイムコレクションといった最適化を行っている

・ガベージコレクションは自動で行われる

##オブジェクトメソッド,"this"
・オブジェクトのプロパティとなっている関数をメソッドと呼ぶ
　
・オブジェクトリテラルでは、メソッドのための短縮構文がある
　例：通常
　let user = {
  　sayHi: function() {
    　alert("Hello");
  　}
　};

　例：短縮構文
　let user = {
  　sayHi() { 
    　alert("Hello");
  　}
　};

・オブジェクトのメソッドがオブジェクトに格納されている情報にアクセスする場合にthisを使う
　例：
　let user = {
  　name: "John",
  　age: 30,

  　sayHi() {
    　// "this" は "現在のオブジェクト"
    　alert(this.name);
  　}
　};
　また、thisの代わりに、user.nameとすることもできるが、もしもuserを何かで上書きした場合にエラーが発生する可能性が高まる
　例：
　let user = {
  　name: "John",
  　age: 30,

  　sayHi() {
    　alert( user.name );
  　}

　};

　let admin = user;
　user = null; // 明らかにするために上書きします

　admin.sayHi();//userがnullのためuser.nameが見つからずエラーになる

・thisは任意の関数内で使用することもでき、その際thisの値は実行時にコンテキストに応じて評価される
　また、オブジェクトなしでthisを使う関数の呼び出しは、一般的にエラーである
　そのため、関数の中にthisがある場合、それはオブジェクトのコンテキストで呼ばれることを期待している

・アロー関数は特別で自身のthisを持たない。もしも、アロー関数でthisを参照した場合、外部の通常の関数から取得される
　例：
　let user = {
  　firstName: "Ilya",
  　sayHi() {
    　let arrow = () => alert(this.firstName);
    　arrow();
  　}
　};

　user.sayHi(); // Ilya

##コンストラクタ、new演算子
・new演算子は暗黙的に空のオブジェクトを作成し、thisに割り当てる
　また、暗黙的にthisの値を返す
　例：
　function User(name) {
  　// this = {};  (暗黙)

  　// this へプロパティを追加
  　this.name = name;
  　this.isAdmin = false;

 　 // return this;  (暗黙)
　}

・一つの複雑なオブジェクトを作成するためのコードがたくさんある場合、次のように即座に呼び出されるコンストラクタ関数でラップすることができる
　let user = new function() {
  　this.name = "John";
  　this.isAdmin = false;

  　// ...ユーザ作成のための他のコード。
  　// 複雑なロジック、文
  　// ローカル変数などを持つかもしれません。
　};

・new.targetという特別なプロパティを使うことで、newを使って呼び出されたのかそうでないのかを確認できる

・コンストラクタのreturnでは、もし、オブジェクトと一緒に呼ばれた場合、thisの代わりにオブジェクトが返される
　また、もし、returnがプリミティブと一緒に呼ばれた場合、それは無視される

・コンストラクタが引数をとらない場合には、newの後の丸括弧を省略できるが、推奨されていない

・thisはプロパティだけでなく、メソッドも追加することができる

##オプショナルチェイニング(Optionalchaining)'?.'
・let user = {}; 
　alert(user.address.street);
　という文があった際に、user.addressはundefinedとなるため、user.address.streetの取得がエラーとなる
　このような現象を避けるために
  alert(user?.address?.street);とすることで、?.の前の値がundefined/nullのとき、そこで処理を打ち切ってundefinedを返す
　このオプショナルチェイニングを用いることでエラーを起こさずに、任意のオブジェクトのプロパティの値を参照することができる

・何かが存在しなくてもOKな場合にのみ?.を利用する

・?.の前の変数は定義されていなければエラーとなる

・user?.sayHi(x++);のように?.の左部分が存在しない場合には、関数の場合も同様に実行されない

・userAdmin.admin?.();の場合には、adminメソッドが定義されているかを評価し、存在しない場合には同様にundefinedを返す

・user?.[key];の場合も同様に、key名のプロパティが存在しているかを評価し、存在しない場合にはundefinedを返す

・delete user?.name;といった使い方もできる

・オプショナルチェイニングは代入の左側では利用できない
　例：　user?.name = "John";//undefind = "John"となるためエラー
